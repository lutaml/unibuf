= Cap'n Proto Support in Unibuf

:toc:
:toclevels: 3

== Purpose

Unibuf provides complete support for Cap'n Proto, a high-performance data interchange format designed for zero-copy serialization.

Features:

* Parse Cap'n Proto schema files (`.capnp`)
* Parse Cap'n Proto binary format
* Serialize to Cap'n Proto binary format
* Schema-driven validation
* Support for all Cap'n Proto constructs
* Round-trip serialization

== Cap'n Proto Overview

Cap'n Proto is designed for:

Zero-copy serialization::
Data can be used directly from serialized form without parsing

Extremely fast::
No encoding/decoding step required

Schema evolution::
Backward and forward compatibility

RPC support::
Built-in RPC interface definitions

Word-aligned::
All data aligned to 8-byte boundaries

== Schema Parsing

=== General

Parse Cap'n Proto schema files to extract struct, enum, and interface definitions.

=== Parsing a schema file

[source,ruby]
----
require "unibuf"

# Parse Cap'n Proto schema
schema = Unibuf.parse_capnproto_schema("addressbook.capnp")  # <1>

# Access schema information
puts "File ID: #{schema.file_id}"  # <2>
puts "Structs: #{schema.struct_names.join(', ')}"  # <3>
puts "Interfaces: #{schema.interface_names.join(', ')}"  # <4>
----
<1> Parse `.capnp` schema file
<2> Get file ID
<3> List all struct names
<4> List all interface names

=== Schema structure

.Example Cap'n Proto schema
[source,capnp]
----
@0x9eb32e19f86ee174;  # File ID

struct Person {
  id @0 :UInt32;      # Field with ordinal
  name @1 :Text;      # Text is a pointer type
  email @2 :Text;
  phones @3 :List(PhoneNumber);  # Generic list type
}

enum Gender {
  male @0;
  female @1;
  other @2;
}

interface Calculator {
  add @0 (a :Int32, b :Int32) -> (result :Int32);  # RPC method
}
----

=== Accessing structs

[source,ruby]
----
# Find struct by name
person = schema.find_struct("Person")  # <1>

# Access fields
person.fields.each do |field|
  puts "#{field.name} @#{field.ordinal} :#{field.type}"  # <2>
end

# Check field properties
id_field = person.find_field("id")  # <3>
puts "Primitive? #{id_field.primitive_type?}"  # <4>
puts "List? #{id_field.list_type?}"  # <5>
----
<1> Find struct definition
<2> Print field with ordinal and type
<3> Find specific field
<4> Check if primitive type
<5> Check if list type

=== Accessing enums

[source,ruby]
----
# Find enum by name
gender = schema.find_enum("Gender")  # <1>

# Access values
gender.values.each do |name, ordinal|
  puts "#{name} = #{ordinal}"  # <2>
end

# Query values
ordinal = gender.find_value("male")  # <3>
name = gender.find_name_by_ordinal(0)  # <4>
----
<1> Find enum definition
<2> Iterate through values
<3> Get ordinal by name
<4> Get name by ordinal

=== Accessing interfaces

[source,ruby]
----
# Find interface by name
calc = schema.find_interface("Calculator")  # <1>

# Access methods
calc.methods.each do |method|
  puts "#{method.name} @#{method.ordinal}"  # <2>
  puts "  Params: #{method.param_names.join(', ')}"  # <3>
  puts "  Results: #{method.result_names.join(', ')}"  # <4>
end
----
<1> Find interface definition
<2> Print method with ordinal
<3> List parameter names
<4> List result names

== Binary Format

=== General

Cap'n Proto binary format uses segments, pointers, and word alignment for efficient zero-copy access.

=== Parsing binary data

[source,ruby]
----
require "unibuf"

# 1. Load schema
schema = Unibuf.parse_capnproto_schema("addressbook.capnp")  # <1>

# 2. Create parser
parser = Unibuf::Parsers::Capnproto::BinaryParser.new(schema)  # <2>

# 3. Parse binary data
data = parser.parse(binary_data, root_type: "Person")  # <3>

# 4. Access fields
puts data[:id]      # => 1  # <4>
puts data[:name]    # => "Alice"  # <5>
puts data[:email]   # => "alice@example.com"  # <6>
----
<1> Parse schema file
<2> Create binary parser
<3> Parse with root type
<4> Access numeric field
<5> Access text field
<6> Access another text field

=== Serializing to binary

[source,ruby]
----
# Create serializer
serializer = Unibuf::Serializers::Capnproto::BinarySerializer.new(schema)  # <1>

# Prepare data
data = {
  id: 1,
  name: "Alice",
  email: "alice@example.com",
  phones: []
}  # <2>

# Serialize
binary = serializer.serialize(data, root_type: "Person")  # <3>

# Write to file
File.binwrite("person.capnp.bin", binary)  # <4>
----
<1> Create serializer with schema
<2> Prepare data as hash
<3> Serialize with root type
<4> Write binary output

=== Round-trip serialization

[source,ruby]
----
# Parse original
original = parser.parse(binary_data, root_type: "Person")  # <1>

# Serialize
output_binary = serializer.serialize(original, root_type: "Person")  # <2>

# Parse again
reparsed = parser.parse(output_binary, root_type: "Person")  # <3>

# Verify equivalence
puts original == reparsed  # => true  # <4>
----
<1> Parse original binary
<2> Serialize to binary
<3> Parse serialized output
<4> Verify semantic equivalence

== Binary Format Details

=== Segment structure

Cap'n Proto organizes data into segments:

Segment table::
Header containing segment count and sizes

Segments::
Contiguous memory blocks containing structs and lists

Word alignment::
All data aligned to 8-byte (64-bit) boundaries

=== Pointer encoding

Pointers are 64-bit words encoding:

Struct pointers (type 0)::
Offset, data word count, pointer word count

List pointers (type 1)::
Offset, element size, element count

Far pointers (type 2)::
Cross-segment references

Capability pointers (type 3)::
RPC capability references

=== Struct layout

Structs have two sections:

Data section::
Inline primitive values (bool, integers, floats)

Pointer section::
References to other structs, lists, text, data

== Architecture

=== Parser components

SegmentReader (`lib/unibuf/parsers/capnproto/segment_reader.rb`)::
Reads segments from binary data with word-aligned access

PointerDecoder (`lib/unibuf/parsers/capnproto/pointer_decoder.rb`)::
Decodes 64-bit pointer words into type, offset, and size information

StructReader (`lib/unibuf/parsers/capnproto/struct_reader.rb`)::
Reads struct data section (primitives) and pointer section (references)

ListReader (`lib/unibuf/parsers/capnproto/list_reader.rb`)::
Reads lists with various element sizes (bit, byte, pointer, composite)

BinaryParser (`lib/unibuf/parsers/capnproto/binary_parser.rb`)::
Coordinates all components for schema-driven parsing

=== Serializer components

SegmentBuilder (`lib/unibuf/serializers/capnproto/segment_builder.rb`)::
Allocates and builds segments with word alignment

PointerEncoder (`lib/unibuf/serializers/capnproto/pointer_encoder.rb`)::
Encodes pointer information into 64-bit words

StructWriter (`lib/unibuf/serializers/capnproto/struct_writer.rb`)::
Writes struct data section and pointer section

ListWriter (`lib/unibuf/serializers/capnproto/list_writer.rb`)::
Writes lists with various element sizes

BinarySerializer (`lib/unibuf/serializers/capnproto/binary_serializer.rb`)::
Coordinates all components for schema-driven serialization

=== Model classes

Schema (`lib/unibuf/models/capnproto/schema.rb`)::
Root schema with file ID, structs, enums, interfaces

StructDefinition (`lib/unibuf/models/capnproto/struct_definition.rb`)::
Struct type with fields, unions, nested types

FieldDefinition (`lib/unibuf/models/capnproto/field_definition.rb`)::
Field specification with ordinal, type, default value

EnumDefinition (`lib/unibuf/models/capnproto/enum_definition.rb`)::
Enum type with values and ordinals

InterfaceDefinition (`lib/unibuf/models/capnproto/interface_definition.rb`)::
RPC interface with methods

MethodDefinition (`lib/unibuf/models/capnproto/method_definition.rb`)::
RPC method with parameters and results

UnionDefinition (`lib/unibuf/models/capnproto/union_definition.rb`)::
Discriminated union within struct

== Command-Line Usage

=== Schema command

[source,shell]
----
# Parse and display Cap'n Proto schema
unibuf schema addressbook.capnp  # <1>

# Output as JSON
unibuf schema addressbook.capnp --format json  # <2>

# Output as YAML
unibuf schema addressbook.capnp --format yaml  # <3>
----
<1> Display schema structure
<2> JSON output format
<3> YAML output format

== Testing

=== Test coverage

Cap'n Proto implementation includes:

Grammar tests (43 tests)::
All schema constructs, primitives, generics, annotations

Integration tests (9 tests)::
Real schema files, nested types, complex structures

Binary parser tests (14 tests)::
Segment reading, pointer decoding, struct/list reading

Binary serializer tests (15 tests)::
Segment building, pointer encoding, round-trip verification

**Total: 81 tests, 100% passing**

=== Running tests

[source,shell]
----
# Run all Cap'n Proto tests
bundle exec rspec spec/unibuf/parsers/capnproto/ spec/unibuf/serializers/capnproto/

# Run specific test suite
bundle exec rspec spec/unibuf/parsers/capnproto/grammar_spec.rb
----

== Implementation Notes

=== Design decisions

Manual pointer management::
Cap'n Proto's dynamic pointer-based format requires runtime offset calculation, making manual implementation more appropriate than declarative approaches

Symmetric architecture::
Reader and writer components mirror each other for consistency

Word-aligned access::
All operations respect 8-byte word boundaries per Cap'n Proto specification

=== Limitations

The current implementation supports:

✅ Single-segment binaries (most common case)
✅ All primitive types
✅ Text and Data types
✅ Lists of primitives
✅ Nested structs
✅ Enums

Future enhancements may add:
- Multi-segment binary support
- Far pointer optimization
- Packed encoding
- RPC runtime support

== References

Cap'n Proto official documentation::
https://capnproto.org/

Language specification::
https://capnproto.org/language.html

Encoding specification::
https://capnproto.org/encoding.html

Example schemas::
https://github.com/capnproto/capnproto/tree/master/c%2B%2B/samples

== Support

For issues, questions, or contributions related to Cap'n Proto support:

* GitHub Issues: https://github.com/lutaml/unibuf/issues
* Documentation: https://github.com/lutaml/unibuf/tree/main/docs

== Copyright and License

Copyright https://www.ribose.com[Ribose Inc.]

Licensed under the 3-clause BSD License.