= Unibuf: Universal Protocol Buffer & FlatBuffer Parser

image:https://img.shields.io/gem/v/unibuf.svg[Gem Version,link=https://rubygems.org/gems/unibuf]
image:https://img.shields.io/github/license/lutaml/unibuf.svg[License,link=https://github.com/lutaml/unibuf/blob/main/LICENSE]
image:https://github.com/lutaml/unibuf/actions/workflows/rake.yml/badge.svg[Build Status,link=https://github.com/lutaml/unibuf/actions/workflows/rake.yml]

== Purpose

Unibuf is a pure Ruby gem for parsing and manipulating Protocol Buffers in both text and binary formats with schema-driven validation.

It provides a fully object-oriented, specification-compliant parser with rich domain models, comprehensive schema validation, wire format decoding, and complete round-trip serialization support.

Key features:

* Parse Protocol Buffers text format (`.txtpb`, `.textproto`)
* Parse Protocol Buffers binary format (`.binpb`) with schema
* Parse Proto3 schemas (`.proto`) for validation
* Schema-driven validation and deserialization
* Wire format decoding (varint, zigzag, all wire types)
* Round-trip serialization with 100% accuracy
* Rich domain models with 45+ behavioral classes
* Complete CLI toolkit for text and binary formats
* Specification-compliant implementation

== Installation

Add this line to your application's Gemfile:

[source,ruby]
----
gem "unibuf"
----

And then execute:

[source,shell]
----
bundle install
----

Or install it yourself as:

[source,shell]
----
gem install unibuf
----

== Features

* <<schema-required-design,Schema-required design>>
* <<parsing-textproto,Parsing text format>>
* <<parsing-binary,Parsing binary format>>
* <<schema-validation,Schema-based validation>>
* <<wire-format,Wire format support>>
* <<round-trip-serialization,Round-trip serialization>>
* <<rich-domain-models,Rich domain models>>
* <<cli-tools,Command-line tools>>

[[schema-required-design]]
== Schema-required design

=== General

Unibuf follows Protocol Buffers' schema-driven architecture. The schema (`.proto` file) defines the message structure and is REQUIRED for binary parsing and recommended for text parsing.

This design ensures type safety and enables proper deserialization of binary formats.

=== Why schema is required

The schema defines:
- Message types and their fields
- Field types and numbers
- Field wire types for binary encoding
- Repeated and optional fields
- Nested message structures

Binary Protocol Buffers cannot be parsed without a schema because the binary format only stores field numbers, not field names or types.

[[parsing-textproto]]
== Parsing Protocol Buffers text format

=== General

Parse human-readable Protocol Buffer text format files following the https://protobuf.dev/reference/protobuf/textformat-spec/[official specification].

=== Parsing text format

[source,ruby]
----
require "unibuf"

# Load schema (recommended for validation)
schema = Unibuf.parse_schema("schema.proto")  # <1>

# Parse text format file
message = Unibuf.parse_textproto_file("data.txtpb")  # <2>

# Validate against schema
validator = Unibuf::Validators::SchemaValidator.new(schema)  # <3>
validator.validate!(message, "MessageType")  # <4>
----
<1> Load Proto3 schema from .proto file
<2> Parse Protocol Buffers text format
<3> Create validator with schema
<4> Validate message against schema

[[parsing-binary]]
== Parsing Protocol Buffers binary format

=== General

Parse binary Protocol Buffer data using wire format decoding with schema-driven deserialization.

The schema is REQUIRED for binary parsing because binary format only stores field numbers, not names or types.

=== Parsing binary format

[source,ruby]
----
require "unibuf"

# 1. Load schema (REQUIRED for binary)
schema = Unibuf.parse_schema("schema.proto")  # <1>

# 2. Parse binary Protocol Buffer file
message = Unibuf.parse_binary_file("data.binpb", schema: schema)  # <2>

# 3. Access fields normally
puts message.find_field("name").value  # <3>
----
<1> Schema is mandatory for binary parsing
<2> Parse binary file with schema
<3> Access fields like text format

=== Binary format from string

[source,ruby]
----
# Read binary data
binary_data = File.binread("data.binpb")

# Parse with schema
schema = Unibuf.parse_schema("schema.proto")
message = Unibuf.parse_binary(binary_data, schema: schema)
----

=== Supported wire types

The binary parser supports all Protocol Buffer wire types:

Varint (Type 0)::
Variable-length integers: int32, int64, uint32, uint64, sint32, sint64, bool, enum

64-bit (Type 1)::
Fixed 8-byte values: fixed64, sfixed64, double

Length-delimited (Type 2)::
Variable-length data: string, bytes, embedded messages, packed repeated fields

32-bit (Type 5)::
Fixed 4-byte values: fixed32, sfixed32, float

[[schema-validation]]
== Schema-based validation

=== General

Validate Protocol Buffer messages (text or binary) against their Proto3 schemas.

=== Validating with schema

[source,ruby]
----
# Load schema
schema = Unibuf.parse_schema("schema.proto")  # <1>

# Parse message (text or binary)
message = Unibuf.parse_binary_file("data.binpb", schema: schema)  # <2>

# Validate
validator = Unibuf::Validators::SchemaValidator.new(schema)  # <3>
errors = validator.validate(message, "MessageType")  # <4>

if errors.empty?
  puts "✓ Valid!"  # <5>
else
  errors.each { |e| puts "  - #{e}" }  # <6>
end
----
<1> Parse the Proto3 schema
<2> Parse binary Protocol Buffer
<3> Create validator with schema
<4> Validate message
<5> Validation passed
<6> Show errors if any

[[wire-format]]
== Wire format support

=== General

Unibuf implements complete Protocol Buffers wire format decoding according to the official specification.

=== Wire format features

Varint decoding::
Efficiently decode variable-length integers used for most numeric types

ZigZag encoding::
Proper handling of signed integers (sint32, sint64) with zigzag decoding

Fixed-width types::
Decode 32-bit and 64-bit fixed-width values (fixed32, fixed64, float, double)

Length-delimited::
Parse strings, bytes, and embedded messages with length prefixes

Schema-driven::
Use schema to determine field types and deserialize correctly

=== Example wire format parsing

[source,ruby]
----
# Schema defines the structure
schema = Unibuf.parse_schema("schema.proto")

# Binary data uses wire format encoding
binary_data = File.binread("data.binpb")

# Parser uses schema to decode wire format
message = Unibuf.parse_binary(binary_data, schema: schema)

# Access decoded fields
message.field_names  # => ["name", "id", "enabled"]
message.find_field("id").value  # => Properly decoded integer
----

[[round-trip-serialization]]
== Round-trip serialization

=== General

Unibuf supports complete round-trip serialization for text format, allowing you to parse, modify, and serialize back while preserving semantic equivalence.

=== Serializing to textproto format

[source,ruby]
----
# Parse (text or binary)
message = Unibuf.parse_textproto_file("input.txtpb")  # <1>

# Serialize to text format
textproto = message.to_textproto  # <2>

File.write("output.txtpb", textproto)  # <3>

# Verify round-trip
reparsed = Unibuf.parse_textproto(textproto)  # <4>
puts message == reparsed  # => true <5>
----
<1> Parse the original file
<2> Serialize to text format
<3> Write to file
<4> Parse the serialized output
<5> Verify semantic equivalence

[[rich-domain-models]]
== Rich domain models

=== General

Unibuf provides rich domain models with comprehensive behavior.

Over 45 classes provide extensive functionality following object-oriented principles.

=== Message model

[source,ruby]
----
# Parse message (text or binary)
schema = Unibuf.parse_schema("schema.proto")
message = Unibuf.parse_binary_file("data.binpb", schema: schema)

# Classification (MECE)
message.nested?            # Has nested messages?
message.scalar_only?       # Only scalar fields?
message.maps?              # Contains maps?
message.repeated_fields?   # Has repeated fields?

# Queries
message.find_field("name")         # Find by name
message.find_fields("tags")        # Find all with name
message.field_names                # All field names
message.repeated_field_names       # Repeated field names

# Traversal
message.traverse_depth_first { |field| ... }
message.traverse_breadth_first { |field| ... }
message.depth  # Maximum nesting depth

# Validation
message.valid?             # Check validity
message.validate!          # Raise if invalid
message.validation_errors  # Get error list
----

[[cli-tools]]
== Command-line tools

=== General

Complete CLI toolkit supporting both text and binary Protocol Buffer formats.

Schema is REQUIRED for proper message type identification.

=== Parse command

[source,shell]
----
# Parse text format
unibuf parse data.txtpb --schema schema.proto --format json

# Parse binary format
unibuf parse data.binpb --schema schema.proto --format json

# Auto-detect format
unibuf parse data.pb --schema schema.proto --format yaml

# Specify message type
unibuf parse data.binpb --schema schema.proto --message-type FamilyProto
----

=== Validate command

[source,shell]
----
# Validate text format
unibuf validate data.txtpb --schema schema.proto

# Validate binary format
unibuf validate data.binpb --schema schema.proto

# Specify message type
unibuf validate data.pb --schema schema.proto --message-type MessageType
----

=== Convert command

[source,shell]
----
# Binary to JSON
unibuf convert data.binpb --schema schema.proto --to json

# Binary to text
unibuf convert data.binpb --schema schema.proto --to txtpb

# Text to JSON
unibuf convert data.txtpb --schema schema.proto --to json
----

=== Schema command

[source,shell]
----
# Inspect schema
unibuf schema schema.proto

# Output as JSON
unibuf schema schema.proto --format json
----

== Architecture

=== Component hierarchy

[source]
----
Unibuf
├── Parsers
│   ├── Textproto          Text format parser
│   │   ├── Grammar        Parslet grammar
│   │   ├── Processor      AST transformation
│   │   └── Parser         High-level API
│   ├── Proto3             Schema parser
│   │   ├── Grammar        Proto3 grammar
│   │   ├── Processor      Schema builder
│   │   └── Parser         Schema API
│   └── Binary             Binary format parser
│       └── WireFormatParser   Wire format decoder
├── Models
│   ├── Message            Protocol Buffer message
│   ├── Field              Message field
│   ├── Schema             Proto3 schema
│   ├── MessageDefinition  Message type definition
│   ├── FieldDefinition    Field specification
│   ├── EnumDefinition     Enum type definition
│   └── Values             Value type hierarchy (5 classes)
├── Validators
│   ├── TypeValidator      Type and range validation
│   └── SchemaValidator    Schema-based validation
└── CLI
    └── Commands           parse, validate, convert, schema
----

=== Design principles

Object-Oriented::
45+ rich classes with extensive behavior.
No anemic data structures.

MECE::
Mutually exclusive, collectively exhaustive classifications.
Complete type hierarchies.

Separation of Concerns::
Clean layer separation: Grammar, Processor, Models, Validators, CLI.

Open/Closed::
Extensible for new formats without modifying core.

Schema-Driven::
Schema-required for binary, recommended for text.
Proper Protocol Buffer architecture.

== Real-World Validation

Curated test suite with diverse Protocol Buffer features:

.Test fixtures
[example]
====
- robotoflex: Multi-axis variable font
- mavenpro: Static font
- opensans: Popular font variants
- playfair: Optical size axis
- wavefont: Custom axes

Validation: 100% parse success, 100% round-trip accuracy
====

== Development

=== Running tests

[source,shell]
----
bundle exec rspec
----

=== Code style

[source,shell]
----
bundle exec rubocop -A
----

== Roadmap

=== Current Version (v1.0.0)

- ✅ Text format parsing
- ✅ Binary format parsing (wire format decoder)
- ✅ Proto3 schema parsing
- ✅ Schema-based validation
- ✅ Complete CLI toolkit
- ✅ 277 comprehensive tests

=== Future work

==== FlatBuffers

- FlatBuffers schema parsing
- FlatBuffers binary parsing
- Performance optimizations
- Additional Protocol Buffer features

== Contributing

Bug reports and pull requests are welcome at https://github.com/lutaml/unibuf.

== Copyright and license

Copyright https://www.ribose.com[Ribose Inc.]

Licensed under the 3-clause BSD License.

