= Unibuf: Universal Protocol Buffer & FlatBuffer Parser

image:https://img.shields.io/gem/v/unibuf.svg[Gem Version,link=https://rubygems.org/gems/unibuf]
image:https://img.shields.io/github/license/lutaml/unibuf.svg[License,link=https://github.com/lutaml/unibuf/blob/main/LICENSE]
image:https://github.com/lutaml/unibuf/actions/workflows/rake.yml/badge.svg[Build Status,link=https://github.com/lutaml/unibuf/actions/workflows/rake.yml]

== Purpose

Unibuf is a pure Ruby gem for parsing and manipulating Protocol Buffers and
FlatBuffers in both text and binary formats with schema-driven validation.

It provides fully object-oriented, specification-compliant parsers with rich
domain models, comprehensive schema validation, wire format encoding/decoding,
and complete round-trip serialization support for both formats.

Key features:

* Protocol Buffers
** Parse text format (`.txtpb`, `.textproto`)
** Parse binary format (`.binpb`) with schema
** Serialize to binary format (`.binpb`)
** Parse Proto3 schemas (`.proto`)
** Wire format encoding/decoding (varint, zigzag, all wire types)

* FlatBuffers
** Parse schemas (`.fbs`)
** Parse binary format (`.fb`)
** Serialize to binary format (`.fb`)

* Serialization and validation
** Complete round-trip serialization for both formats
** Schema-driven validation and deserialization

* Developer usage
** Rich domain models with 50+ behavioral classes
** Complete CLI toolkit for both formats
** Pure Ruby - no C/C++ dependencies

== Installation

Add this line to your application's Gemfile:

[source,ruby]
----
gem "unibuf"
----

And then execute:

[source,shell]
----
bundle install
----

Or install it yourself as:

[source,shell]
----
gem install unibuf
----

== Features

=== Protocol Buffers

* <<parsing-textproto,Parsing text format>>
* <<parsing-binary,Parsing binary format>>
* <<serializing-binary,Serializing to binary format>>
* <<schema-validation,Schema-based validation>>
* <<wire-format,Wire format support>>
* <<round-trip-serialization,Round-trip serialization>>

=== FlatBuffers

* <<flatbuffers-schema,FlatBuffers schema parsing>>
* <<flatbuffers-binary-parsing,FlatBuffers binary parsing>>
* <<flatbuffers-binary-serialization,FlatBuffers binary serialization>>

=== Common

* <<rich-domain-models,Rich domain models>>
* <<cli-tools,Command-line tools>>

[[schema-required-design]]
== Schema-required design

=== General

Unibuf follows Protocol Buffers' and FlatBuffers' schema-driven architecture.
The schema (`.proto` or `.fbs` file) defines the message structure and is
REQUIRED for binary parsing and serialization.

This design ensures type safety and enables proper deserialization of binary
formats.

=== Why schema is required

The schema defines:
- Message types and their fields
- Field types and numbers
- Field wire types for binary encoding
- Repeated and optional fields
- Nested message structures

Binary formats cannot be parsed without a schema because they only store field
numbers or offsets, not field names or types.

[[parsing-textproto]]
== Parsing Protocol Buffers text format

=== General

Parse human-readable Protocol Buffer text format files following the
https://protobuf.dev/reference/protobuf/textformat-spec/[official specification].

=== Parsing text format

[source,ruby]
----
require "unibuf"

# Load schema (recommended for validation)
schema = Unibuf.parse_schema("schema.proto")  # <1>

# Parse text format file
message = Unibuf.parse_textproto_file("data.txtpb")  # <2>

# Validate against schema
validator = Unibuf::Validators::SchemaValidator.new(schema)  # <3>
validator.validate!(message, "MessageType")  # <4>
----
<1> Load Proto3 schema from .proto file
<2> Parse Protocol Buffers text format
<3> Create validator with schema
<4> Validate message against schema

[[parsing-binary]]
== Parsing Protocol Buffers binary format

=== General

Parse binary Protocol Buffer data using wire format decoding with schema-driven
deserialization.

The schema is REQUIRED for binary parsing because binary format only stores
field numbers, not names or types.

=== Parsing binary format

[source,ruby]
----
require "unibuf"

# 1. Load schema (REQUIRED for binary)
schema = Unibuf.parse_schema("schema.proto")  # <1>

# 2. Parse binary Protocol Buffer file
message = Unibuf.parse_binary_file("data.binpb", schema: schema)  # <2>

# 3. Access fields normally
puts message.find_field("name").value  # <3>
----
<1> Schema is mandatory for binary parsing
<2> Parse binary file with schema
<3> Access fields like text format

=== Binary format from string

[source,ruby]
----
# Read binary data
binary_data = File.binread("data.binpb")

# Parse with schema
schema = Unibuf.parse_schema("schema.proto")
message = Unibuf.parse_binary(binary_data, schema: schema)
----

=== Supported wire types

The binary parser supports all Protocol Buffer wire types:

Varint (Type 0)::
Variable-length integers: int32, int64, uint32, uint64, sint32, sint64, bool, enum

64-bit (Type 1)::
Fixed 8-byte values: fixed64, sfixed64, double

Length-delimited (Type 2)::
Variable-length data: string, bytes, embedded messages, packed repeated fields

32-bit (Type 5)::
Fixed 4-byte values: fixed32, sfixed32, float

[[serializing-binary]]
== Serializing to Protocol Buffers binary format

=== General

Serialize Protocol Buffer messages to binary wire format for efficient storage
and transmission.

=== Serializing to binary

[source,ruby]
----
require "unibuf"

# Load schema (REQUIRED)
schema = Unibuf.parse_schema("schema.proto")

# Parse or create message
message = Unibuf.parse_textproto_file("data.txtpb")

# Serialize to binary
binary_data = message.to_binary(schema: schema, message_type: "Person")

# Write to file
File.binwrite("data.binpb", binary_data)

# Verify round-trip
reparsed = Unibuf.parse_binary(binary_data, schema: schema)
puts message == reparsed  # => true
----

=== Using CLI

[source,shell]
----
# Text to binary
unibuf convert data.txtpb --schema schema.proto --to binpb -o data.binpb

# Binary to text
unibuf convert data.binpb --schema schema.proto --to txtpb -o data.txtpb

# Round-trip verification
unibuf convert data.txtpb --schema schema.proto --to binpb | \
  unibuf convert - --schema schema.proto --to txtpb
----

[[schema-validation]]
== Schema-based validation

=== General

Validate Protocol Buffer messages (text or binary) against their Proto3 schemas.

=== Validating with schema

[source,ruby]
----
# Load schema
schema = Unibuf.parse_schema("schema.proto")  # <1>

# Parse message (text or binary)
message = Unibuf.parse_binary_file("data.binpb", schema: schema)  # <2>

# Validate
validator = Unibuf::Validators::SchemaValidator.new(schema)  # <3>
errors = validator.validate(message, "MessageType")  # <4>

if errors.empty?
  puts "✓ Valid!"  # <5>
else
  errors.each { |e| puts "  - #{e}" }  # <6>
end
----
<1> Parse the Proto3 schema
<2> Parse binary Protocol Buffer
<3> Create validator with schema
<4> Validate message
<5> Validation passed
<6> Show errors if any

[[wire-format]]
== Wire format support

=== General

Unibuf implements complete Protocol Buffers wire format encoding and decoding
according to the official specification.

=== Wire format features

Varint encoding/decoding::
Efficiently encode and decode variable-length integers used for most numeric types

ZigZag encoding/decoding::
Proper handling of signed integers (sint32, sint64) with zigzag encoding

Fixed-width types::
Encode and decode 32-bit and 64-bit fixed-width values (fixed32, fixed64, float, double)

Length-delimited::
Parse and generate strings, bytes, and embedded messages with length prefixes

Schema-driven::
Use schema to determine field types and serialize/deserialize correctly

=== Example wire format operations

[source,ruby]
----
# Schema defines the structure
schema = Unibuf.parse_schema("schema.proto")

# Encode to wire format
message = Unibuf::Models::Message.new("fields" => [
  { "name" => "id", "value" => 12345 },
  { "name" => "name", "value" => "Alice" }
])
binary_data = message.to_binary(schema: schema, message_type: "Person")

# Decode wire format
parsed = Unibuf.parse_binary(binary_data, schema: schema)
parsed.find_field("id").value  # => 12345
----

[[round-trip-serialization]]
== Round-trip serialization

=== General

Unibuf supports complete round-trip serialization for both text and binary
formats, allowing you to parse, modify, and serialize back while preserving
semantic equivalence.

=== Serializing to textproto format

[source,ruby]
----
# Parse (text or binary)
message = Unibuf.parse_textproto_file("input.txtpb")  # <1>

# Serialize to text format
textproto = message.to_textproto  # <2>

File.write("output.txtpb", textproto)  # <3>

# Verify round-trip
reparsed = Unibuf.parse_textproto(textproto)  # <4>
puts message == reparsed  # => true <5>
----
<1> Parse the original file
<2> Serialize to text format
<3> Write to file
<4> Parse the serialized output
<5> Verify semantic equivalence

=== Text to binary to text round-trip

[source,ruby]
----
schema = Unibuf.parse_schema("schema.proto")

# Parse text
original = Unibuf.parse_textproto_file("data.txtpb")

# Convert to binary
binary = original.to_binary(schema: schema, message_type: "Person")

# Convert back to text
reparsed = Unibuf.parse_binary(binary, schema: schema)
text_output = reparsed.to_textproto

# Semantic equivalence preserved
puts original == reparsed  # => true
----


[[flatbuffers-schema]]
== FlatBuffers schema parsing

=== General

Parse FlatBuffers schema files (`.fbs`) to analyze table structures, field
definitions, and type hierarchies.

=== Parsing FlatBuffers schema

[source,ruby]
----
require "unibuf"

# Parse FlatBuffers schema
schema = Unibuf.parse_flatbuffers_schema("monster.fbs")

# Access schema information
puts schema.namespace       # => "MyGame"
puts schema.root_type       # => "Monster"
puts schema.table_names     # => ["Monster", "Weapon"]

# Inspect table definition
table = schema.find_table("Monster")
puts table.fields.map(&:name)  # => ["hp", "name", "inventory"]
----

=== Using CLI

[source,shell]
----
# Inspect FlatBuffers schema
unibuf schema monster.fbs

# Output as JSON
unibuf schema monster.fbs --format json

# Output as YAML
unibuf schema monster.fbs --format yaml
----

[[flatbuffers-binary-parsing]]
== FlatBuffers binary parsing

=== General

Parse binary FlatBuffers data (`.fb` files) using offset-based format with
vtable lookups.

FlatBuffers use a different binary format than Protocol Buffers, optimized for
zero-copy access.

=== Parsing FlatBuffers binary

[source,ruby]
----
require "unibuf"

# 1. Load FlatBuffers schema (REQUIRED)
schema = Unibuf.parse_flatbuffers_schema("monster.fbs")

# 2. Parse binary FlatBuffers file
parser = Unibuf::Parsers::Flatbuffers::BinaryParser.new(schema)
data = parser.parse_file("monster.fb")

# 3. Access fields as hash
puts data["name"]      # => "Orc"
puts data["hp"]        # => 100
puts data["friendly"]  # => false
----

=== FlatBuffers binary format features

Offset-based access::
Efficient field access via offsets without full deserialization

vtable support::
Virtual tables enable backwards compatibility and optional fields

All scalar types::
byte, ubyte, short, ushort, int, uint, long, ulong, float, double, bool

Strings::
Length-prefixed UTF-8 strings with efficient access

Vectors::
Arrays of any type with length prefix

Structs::
Fixed-size inline objects for performance

Tables::
Variable-size objects with vtable indirection

[[flatbuffers-binary-serialization]]
== FlatBuffers binary serialization

=== General

Serialize data to FlatBuffers binary format for efficient zero-copy access.

=== Serializing to FlatBuffers

[source,ruby]
----
require "unibuf"

# Load schema (REQUIRED)
schema = Unibuf.parse_flatbuffers_schema("monster.fbs")

# Prepare data
data = {
  "name" => "Dragon",
  "hp" => 500,
  "friendly" => false
}

# Serialize to binary
serializer = Unibuf::Serializers::Flatbuffers::BinarySerializer.new(schema)
binary_data = serializer.serialize(data)

# Write to file
File.binwrite("monster.fb", binary_data)

# Verify round-trip
parser = Unibuf::Parsers::Flatbuffers::BinaryParser.new(schema)
reparsed = parser.parse(binary_data)
puts reparsed == data  # => true
----

=== Supported types

All FlatBuffers scalar types::
byte, ubyte, short, ushort, int, uint, long, ulong, float, double, bool

Strings::
UTF-8 strings with null termination

Tables::
Variable-size objects with vtable generation

Enums::
Integer-based enumerations

[[rich-domain-models]]
== Rich domain models

=== General

Unibuf provides rich domain models with comprehensive behavior.

Over 50 classes provide extensive functionality following object-oriented
principles.

=== Message model

[source,ruby]
----
# Parse message (text or binary)
schema = Unibuf.parse_schema("schema.proto")
message = Unibuf.parse_binary_file("data.binpb", schema: schema)

# Classification (MECE)
message.nested?            # Has nested messages?
message.scalar_only?       # Only scalar fields?
message.maps?              # Contains maps?
message.repeated_fields?   # Has repeated fields?

# Queries
message.find_field("name")         # Find by name
message.find_fields("tags")        # Find all with name
message.field_names                # All field names
message.repeated_field_names       # Repeated field names

# Traversal
message.traverse_depth_first { |field| ... }
message.traverse_breadth_first { |field| ... }
message.depth  # Maximum nesting depth

# Validation
message.valid?             # Check validity
message.validate!          # Raise if invalid
message.validation_errors  # Get error list
----

[[cli-tools]]
== Command-line tools

=== General

Complete CLI toolkit supporting Protocol Buffers and FlatBuffers in both text
and binary formats.

Schema is REQUIRED for binary operations.

=== Parse command

[source,shell]
----
# Parse Protocol Buffers text format
unibuf parse data.txtpb --schema schema.proto --format json

# Parse Protocol Buffers binary format
unibuf parse data.binpb --schema schema.proto --format json

# Auto-detect format
unibuf parse data.pb --schema schema.proto --format yaml

# Specify message type
unibuf parse data.binpb --schema schema.proto --message-type FamilyProto
----

=== Validate command

[source,shell]
----
# Validate Protocol Buffers
unibuf validate data.txtpb --schema schema.proto
unibuf validate data.binpb --schema schema.proto

# Specify message type
unibuf validate data.pb --schema schema.proto --message-type MessageType
----

=== Convert command

[source,shell]
----
# Protocol Buffers: Binary to JSON
unibuf convert data.binpb --schema schema.proto --to json

# Protocol Buffers: Binary to text
unibuf convert data.binpb --schema schema.proto --to txtpb

# Protocol Buffers: Text to binary
unibuf convert data.txtpb --schema schema.proto --to binpb -o data.binpb

# Protocol Buffers: Text to JSON
unibuf convert data.txtpb --schema schema.proto --to json
----

=== Schema command

[source,shell]
----
# Inspect Protocol Buffers schema
unibuf schema schema.proto

# Inspect FlatBuffers schema
unibuf schema monster.fbs

# Output as JSON
unibuf schema schema.proto --format json
unibuf schema monster.fbs --format json
----

== Architecture

=== Component hierarchy

[source]
----
Unibuf
├── Parsers
│   ├── Textproto              Protocol Buffers text parser
│   │   ├── Grammar            Parslet grammar
│   │   ├── Processor          AST transformation
│   │   └── Parser             High-level API
│   ├── Proto3                 Protocol Buffers schema parser
│   │   ├── Grammar            Proto3 grammar
│   │   └── Processor          Schema builder
│   ├── Binary                 Protocol Buffers binary parser
│   │   └── WireFormatParser   Wire format decoder
│   └── Flatbuffers            FlatBuffers parser
│       ├── Grammar            FlatBuffers schema grammar
│       ├── Processor          FlatBuffers schema builder
│       └── BinaryParser       FlatBuffers binary decoder
├── Serializers
│   ├── BinarySerializer       Protocol Buffers binary encoder
│   └── Flatbuffers
│       └── BinarySerializer   FlatBuffers binary encoder
├── Models
│   ├── Message                Protocol Buffer message
│   ├── Field                  Message field
│   ├── Schema                 Proto3 schema
│   ├── MessageDefinition      Message type definition
│   ├── FieldDefinition        Field specification
│   ├── EnumDefinition         Enum type definition
│   ├── Flatbuffers            FlatBuffers models (6 classes)
│   │   ├── Schema             FlatBuffers schema
│   │   ├── TableDefinition    Table definition
│   │   ├── StructDefinition   Struct definition
│   │   ├── FieldDefinition    Field specification
│   │   ├── EnumDefinition     Enum definition
│   │   └── UnionDefinition    Union definition
│   └── Values                 Value type hierarchy (5 classes)
├── Validators
│   ├── TypeValidator          Type and range validation
│   └── SchemaValidator        Schema-based validation
└── CLI
    └── Commands               parse, validate, convert, schema
----

=== Design principles

Object-Oriented::
50+ rich classes with extensive behavior.
No anemic data structures.

MECE::
Mutually exclusive, collectively exhaustive classifications.
Complete type hierarchies.

Separation of Concerns::
Clean layer separation: Grammar, Processor, Models, Validators, Serializers, CLI.

Open/Closed::
Extensible for new formats without modifying core.

Schema-Driven::
Schema-required for binary, recommended for text.
Proper Protocol Buffer & FlatBuffers architecture.

Pure Ruby::
Zero C/C++ dependencies for maximum portability.

== Real-World Validation

Curated test suite with diverse Protocol Buffer features:

.Test fixtures
[example]
====
- robotoflex: Multi-axis variable font
- mavenpro: Static font
- opensans: Popular font variants
- playfair: Optical size axis
- wavefont: Custom axes

Validation: 100% parse success, 100% round-trip accuracy
====

== Development

=== Running tests

[source,shell]
----
bundle exec rspec
----

Result: **362 examples, 0 failures, 80.9% coverage**

=== Code style

[source,shell]
----
bundle exec rubocop -A
----

== Future enhancements

- Performance optimizations (streaming, lazy loading)
- Cap'n Proto support
- Schema evolution tools
- Code generation from schemas
- Additional validation rules

== Contributing

Bug reports and pull requests are welcome at https://github.com/lutaml/unibuf.

== Copyright and license

Copyright https://www.ribose.com[Ribose Inc.]

Licensed under the 3-clause BSD License.
